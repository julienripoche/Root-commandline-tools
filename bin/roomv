#!/usr/bin/python

"""Commandline to move an object from a root file to an other root file"""

from pattern_to_file import *
from pattern_to_object import *
from DirCopy import *
import argparse
import ROOT

# Collect arguments with the module argparse
parser = argparse.ArgumentParser(description="commandline to move an object from a root file to an other")
parser.add_argument("complete_pattern_source", \
                    help="file path and object path in the file with the syntax : [file_path/]file[.root]:[object_path/]object", \
                    nargs='+')
parser.add_argument("complete_pattern_dest", \
                    help="file path and object path in the file with the syntax : [file_path/]file[.root]:[object_path/]object")
args = parser.parse_args()

# Create a dictionnary with file_name as key and which contains list of paths
source_dict = {}
for complete_pattern in args.complete_pattern_source:
    complete_pattern_split = complete_pattern.split(":")
    if complete_pattern_split[0] in ["http","https","ftp"]: # File from the web
        complete_pattern_split[0] += ":"+complete_pattern_split[1]
        del complete_pattern_split[1]
        name_list = [complete_pattern_split[0]]
    else: # Or not
        name_list = pattern_to_file(complete_pattern_split[0])
    for file_name in name_list:
        if len(complete_pattern_split)==2: # There is a pattern
            pattern = complete_pattern_split[1]
            path_list = pattern_to_object(file_name,pattern)
        else:
            path_list = []
        if not file_name in source_dict:
            source_dict[file_name] = path_list
        else:
            source_dict[file_name].extend(path_list)

# Create a dictionnary with file_name as key and which contains list of paths
complete_pattern = args.complete_pattern_dest
complete_pattern_split = complete_pattern.split(":")

if complete_pattern_split[0] in ["http","https","ftp"]: # File from the web
    complete_pattern_split[0] += ":"+complete_pattern_split[1]
    del complete_pattern_split[1]
    dest_name = complete_pattern_split[0]
else: # Or not
    pattern_name = complete_pattern_split[0]
    dest_name = os.path.abspath(os.path.expanduser(os.path.normpath(pattern_name)))

if len(complete_pattern_split)==2: # There is a pattern
    pattern = complete_pattern_split[1]
    pattern_norm = os.path.normpath(pattern)
    pattern_split = pattern_norm.split("/")
    dest_path = pattern_split
else:
    dest_path = []

# Create a dictionnary with options
opt_dict = vars(args)
del opt_dict["complete_pattern_source"]
del opt_dict["complete_pattern_dest"]

# Loop on the root files
dest_file = ROOT.TFile.Open(dest_name,"update")
for source_name, path_list in source_dict.items():
    if source_name != dest_name:
        source_file = ROOT.TFile.Open(source_name,"update")
    else:
        source_file = dest_file
    if path_list == []:
        source_file.cd()
        path_list = [[key.GetName()] for key in ROOT.gDirectory.GetListOfKeys()]
    for source_path in path_list:
        chg_dir(source_file,source_path[:-1])
        key = ROOT.gDirectory.GetKey(source_path[-1])
        classname = key.GetClassName()
        cl = ROOT.gROOT.GetClass(classname)
        if (not cl):
            continue
        if (cl.InheritsFrom(ROOT.TDirectory.Class())):
            chg_dir(source_file,source_path[:-1])
            subdir = ROOT.gDirectory.Get(source_path[-1]) # Get the TDirectory ...
            chg_dir(dest_file,dest_path)
            CopyDir(subdir)
            chg_dir(dest_file,dest_path)
        #else if (cl.InheritsFrom(ROOT.TTree::Class())):
        #    TTree *T = (TTree*)source.Get(key.GetName())
        #    adir.cd()
        #    TTree *newT = T.CloneTree(-1,"fast")
        #    newT.Write()
        else :
            chg_dir(source_file,source_path[:-1])
            obj = key.ReadObj()
            chg_dir(dest_file,dest_path)
            obj.Write()

        chg_dir(source_file,source_path[:-1])
        ROOT.gDirectory.Delete(source_path[-1]+";*") # It doesn't work without the +";*" for cycles

    if source_name != dest_name:
        source_file.Close()
dest_file.Close()
